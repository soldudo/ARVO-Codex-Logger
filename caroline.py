import subprocess
import json
import time
from datetime import datetime
from pathlib import Path
from typing import Optional
from queries import get_context

vuln_list = [40096184, 42488087, 42513136, 42530547, 424242614]
project_list = ['skia', 'wolfssl', 'binutils-preconditions', 'opensc', 'libxml2']
fuzz_target = [
    '',
    './out/fuzzer-wolfssl-server-randomize tmp/poc', # 42488087
    './out/fuzz_objdump_safe tmp/poc', # 42513136
    '',
    ''
]
crash_list = [
    '',
    'Heap-buffer-overflow WRITE 1', # 42488087
    'Heap-double-free', # 42513136
    '',
    ''
]

experiment_no = 2  # Change this index to run different experiments
vuln = f'arvo-{vuln_list[experiment_no]}-vul'
project = project_list[experiment_no]
crash_type = crash_list[experiment_no]

patch1_crash = 'runs/arvo-42513136-vul-1766251130/crash_log_patch1.txt'

crash_path = Path(__file__).parent / patch1_crash

# path to crash log generated by fuzzing with poc
# crash_path = Path(__file__).parent / vuln / "crash_report.log"

try:
    with open(crash_path, "r", encoding="utf-8", errors="replace") as f:
        crash_log = f.read()
except FileNotFoundError:
    print(f"Error: The file {crash_path} was not found.")

workspace_list = [
    '',
    f'{vuln}/src/wolfssl', # 42488087
    f'{vuln}/src/binutils-preconditions', # 42513136
    '',
    ''
]
workspace = Path(__file__).parent / workspace_list[experiment_no]

prompt = f'Your previous fix did not fix the crash according to the new crash log: '
prompt += f'<crash_log>{crash_log}</crash_log>'
prompt += 'The correct fix addresses a problem in the function fuzz_display_file2 in ada_nm.h at line 239, and two problems in the function fuzz_display_object_bfd in ada_objdump.h at lines 95 and 114. Use this information to reattempt the fix.'

# prompt_initial = f'Find and fix the bug in {project} to remove the {crash_type} shown in the log below. Provide the lines of code and file locations changed in this task.\n{crash_log}\n'
# prompt_fail = f'Your previous fix did not remove the crash. Review the new crash log'

def conduct_run(vuln: str, prompt: str):
    run_timestamp = int(time.time())
    log_path = Path(__file__).parent / "runs" / f"{vuln}-{run_timestamp}.log"
    workspace = Path(__file__).parent / vuln

    log_path.parent.mkdir(parents=True, exist_ok=True)


    command = ['codex', 'exec', '--json', '--full-auto', '--cd', str(workspace), 'resume', '--last', prompt]
    # command_initial = ['codex', 'exec', '--json', '--full-auto', '--cd', str(workspace), prompt]


    print("using command:", command)
    print(f'Logging to {log_path}\n')
    
    start_time = time.time()
    duration = 0.0
    return_code = None

    with open(log_path, 'w', encoding='utf-8') as log_file:
        metadata = {
            'vuln': vuln,
            'workspace': str(workspace),
            'command': command,
            'timestamp_iso': datetime.now().isoformat(),
            'timestamp_unix': start_time,
            'prompt': prompt
        }

        log_file.write(json.dumps(metadata) + '\n')
        log_file.flush()

        process = subprocess.Popen(
            command,
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE,
            text=True,
            bufsize=1
        )


        try:
            for line in process.stdout:
                line = line.rstrip('\n')
                if not line.strip():
                    continue

                log_entry = {
                    'log_type': 'stream_output',
                    'timestamp_iso': datetime.now().isoformat(),
                    'timestamp_unix': time.time(),
                    'data': None
                }

                try:
                    event = json.loads(line)
                    log_entry['data'] = event

                    msg_type = event.get('type')

                    # Case 1: Command Execution Result
                    if msg_type == 'item.completed' and event.get('item', {}).get('type') == 'command_execution':
                        item = event['item']
                        raw_output = item.get('aggregated_output', '')
                        exit_code = item.get('exit_code')
                        print(f"\n[Command Result - Exit {exit_code}]:\n{raw_output}")

                    # Case 2: Reasoning (Thinking)
                    elif msg_type == 'item.completed' and event.get('item', {}).get('type') == 'reasoning':
                        text = event['item'].get('text', '').replace('**', '')
                        print(f"\n[Thinking]: {text}")
                    
                    # Case 3: Executing Command
                    elif msg_type == 'item.started' and event.get('item', {}).get('type') == 'command_execution':
                        print(f"\n> [Executing]: {event['item'].get('command')}")

                    # Case 4: Final Message
                    elif msg_type == 'item.completed' and event.get('item', {}).get('type') =='agent_message':
                        text = event['item'].get('text', '')
                        print(f"\n[agent_message]: {text}")



                except json.JSONDecodeError:
                    print(f'Non-JSON output: {line}')
                    log_entry['data'] = {'raw_text': line}
                    continue
                
                log_file.write(json.dumps(log_entry) + '\n')
                log_file.flush()
                # Consider adding timestamp to log entries by writing wrapped json
                # timed_event = {
                #     'timestamp': time.time(),
                #     'event': event
                # }

                
            return_code = process.wait()
            end_time = time.time()
            duration = end_time - start_time


            stderr_output = process.stderr.read()
            if stderr_output:
                print('\nCodex stderr output:\n', stderr_output)
                log_file.write(json.dumps({
                    'log_type': 'stderr_output',
                    'timestamp_iso': datetime.now().isoformat(),
                    'timestamp_unix': time.time(),
                    'data': stderr_output
                }) + '\n')
                # log_file.flush() # copilot rec
            
            print(f'Codex finished with return code {return_code} in {duration:.2f} seconds.')

        except Exception as e:
            print(f'Error during execution: {e}')
            log_file.write(json.dumps({
                'log_type': 'execution_error',
                'timestamp_iso': datetime.now().isoformat(),
                'timestamp_unix': time.time(),
                'data': str(e)
            }) + '\n')
            raise e
                
        finally:
            meta_end = {
                'log_type': 'session_end',
                'timestamp_iso': datetime.now().isoformat(),
                'timestamp_unix': time.time(),
                'duration_seconds': duration,
                'return_code': return_code
            }
            log_file.write(json.dumps(meta_end) + '\n')
            log_file.close()

if __name__ == "__main__":
    conduct_run(vuln, prompt)